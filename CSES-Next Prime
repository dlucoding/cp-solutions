// Thank God!
#include <bits/stdc++.h>
#include <cstdint>
#include <numeric>
using namespace std;

// Aliases for simple data types
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;

// Neat definitions
#define PI 3.14159265358979
#define E 2.7182818284590
#define all(x) x.begin(), x.end()
#define nl '\n'
#define sqrt sqrtl
#define sz(a) (int)a.size()

// RNG
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

// simplified alias for vectors
template <class T>
using v = vector<T>;

// overloaded stream operators
#pragma region streams
template <class T1, class T2>
istream &operator>>(istream &in, pair<T1, T2> &p)
{
    in >> p.first >> p.second;
    return in;
}

template <class T1, class T2>
ostream &operator<<(ostream &out, pair<T1, T2> &p)
{
    out << p.first << " " << p.second << nl;
    return out;
}

template <class T, size_t N>
istream &operator>>(istream &in, array<T, N> &a)
{
    for (T &x : a)
        in >> x;
    return in;
}

template <class T, size_t N>
ostream &operator<<(ostream &out, array<T, N> &a)
{
    for (T &x : a)
        out << x << nl;
    return out;
}

template <class T>
istream &operator>>(istream &in, v<T> &v)
{
    for (auto &x : v)
        in >> x;
    return in;
}
template <class T1, class T2>
ostream &operator<<(ostream &out, v<pair<T1, T2>> &v)
{
    for (auto &p : v)
        cout << p;
    return out;
}

template <class T>
ostream &operator<<(ostream &out, v<T> &v)
{
    for (int i = 0; i < v.size(); i++)
        cout << v[i] << " \n"[i == sz(v) - 1];
    return out;
}

#pragma endregion

// MULTITEST TOGGLE
const bool test = true;
/*-------------------------------------------------------------------------------*/
#pragma region templates
#pragma endregion
v<ll> primes;

void solve()
{
    ll N;
    cin >> N;
    // for each number i in 1...sqrt(N)
    // mark the least multiple of i greater than N and do a sieve
    // then search from N+1 upwards 
    v<ll> flag(1000,false);
    for(ll i = 2; i<=1e6; i++)
        for(ll j = (N+i-1)/i*i; j<N+1000; j+=i)
            if(j>i)
                flag[j-N]=true;
    int ind = 1;
    while(flag[ind])
        ind++;
    cout<<N+ind<<nl;
    // This basically works in O(1) with high constant factor.
    // t<=20 so we should be okay
}

int main()
{
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#else
    ios::sync_with_stdio(0);
    cin.tie(0);
#endif

    // Conjecture: we only need to check N+1 -> N+1000
    // based on the spacing of primes 

    // const ll N = 1e6;
    // v<bool> isPrime(N+1, true);
    // ll mxDiff=0;
    // for(ll i=2; i<=N; i++)
    //     if(isPrime[i]) {
    //         for(ll j=2*i; j<=N; j+=i)
    //             isPrime[j]=false;
    //         if(primes.size()&&i-primes.back()>=mxDiff)
    //             mxDiff=i-primes.back();
    //         primes.push_back(i);
    //     }
    // cout << sz(primes) << nl;
    // testcases
    int t;
    if (test)
        cin >> t;
    else
        t = 1;
    while (t--)
    {
        solve();
    }
}

/*
-try out more cases
-attack the problem creatively/at different angles
-what am i missing?
-CHECK YOUR CODE
-pay attention to BOUNDS
-errors - out of bounds, edge case(n=0, n=1?), integer overflow, etc.
-WHEN IN DOUBT, USE LONG LONG
-check the for loops
-watch out for division errors (use double and ll when needed)
*/
// Thank God!
